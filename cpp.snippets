# ~/.vim/bundle/vim-snippets/UltiSnips/cpp.snippets

snippet snips "all snippets"
/*
snips
inc
main
for
forc
cl
ns
tp
cla
fun
mfun
array
vector
deque
flist
list
set
map
mset
mmap
uset
umap
umset
ummap
stack
queue
pqueue
contest
*/
endsnippet

snippet inc
#include <${1:iostream}>
endsnippet

snippet main
int main() {
	${0}
}
endsnippet

snippet for "for loop (for)"
for ($2 = 0; $2 < ${1:count}; ++${2:i}) {
	${VISUAL}$0
}
endsnippet

snippet forc "general for loop (for)"
for (${6:auto} ${1:i} = ${2:v.begin()}; `!p import re; snip.rv = re.split("[^\w]",t[1])[-1]` ${4:!=} ${3:`!p m = re.search(r'^(?:(.*)(\.|->)begin\(\)|((?:std|boost)::)?begin\((.*)\))$', t[2]); snip.rv = (((m.group(3) if m.group(3) else "") + "end(" + m.group(4) + ")") if m.group(4) else (m.group(1) + m.group(2) + "end()")) if m else ""`}; ${5:++`!p snip.rv = t[1].split(" ")[-1]`}) {
	${VISUAL}$0
}
endsnippet

snippet cl "class .. (class)"
class ${1:`!p snip.rv = snip.basename or "name"`} {
public:
	${1/(\w+).*/$1/}(${2:arguments});

private:
	${3:/* data */}
};
endsnippet

snippet ns "namespace .. (namespace)"
namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`} {

${VISUAL}$0

}${1/.+/ \/\/ /m}$1${1/.+//m}
endsnippet

snippet tp "template <typename ..> (template)"
template <typename ${1:_InputIter}>
endsnippet

snippet cla "An entire .h generator"
#pragma once

namespace${1/.+/ /m}${1:`!p snip.rv = snip.basename or "name"`} {

class ${2:`!p snip.rv = snip.basename or "name"`} {
public:
	${2/(\w+).*/$1/}(${3:arguments});

private:
	${4:/* data */}
};

}${1/.+/ \/\/ /m}$1${1/.+//m}
endsnippet

snippet fun
${1:ReturnType} ${2:FunctionName}(${3:param}) {
	${0:FunctionBody}
}
endsnippet

snippet mfun
${4:void} ${1:`vim_snippets#Filename('$1', 'ClassName')`}::${2:memberFunction}(${3}) {
	${0}
}
endsnippet

##
## STL Collections
# std::array
snippet array
std::array<${1:T}, ${2:N}> ${3};
endsnippet
# std::vector
snippet vector
std::vector<${1:T}> ${2};
endsnippet
# std::deque
snippet deque
std::deque<${1:T}> ${2};
endsnippet
# std::forward_list
snippet flist
std::forward_list<${1:T}> ${2};
endsnippet
# std::list
snippet list
std::list<${1:T}> ${2};
endsnippet
# std::set
snippet set
std::set<${1:T}> ${2};
endsnippet
# std::map
snippet map
std::map<${1:Key}, ${2:T}> ${3};
endsnippet
# std::multiset
snippet mset
std::multiset<${1:T}> ${2};
endsnippet
# std::multimap
snippet mmap
std::multimap<${1:Key}, ${2:T}> ${3};
endsnippet
# std::unordered_set
snippet uset
std::unordered_set<${1:T}> ${2};
endsnippet
# std::unordered_map
snippet umap
std::unordered_map<${1:Key}, ${2:T}> ${3};
endsnippet
# std::unordered_multiset
snippet umset
std::unordered_multiset<${1:T}> ${2};
endsnippet
# std::unordered_multimap
snippet ummap
std::unordered_multimap<${1:Key}, ${2:T}> ${3};
endsnippet
# std::stack
snippet stack
std::stack<${1:T}> ${2};
endsnippet
# std::queue
snippet queue
std::queue<${1:T}> ${2};
endsnippet
# std::priority_queue
snippet pqueue
std::priority_queue<${1:T}> ${2};
endsnippet
##
## STL smart pointers
# std::shared_ptr
snippet sp
auto ${1} = std::make_shared<${2:T}>(${3});
endsnippet
# std::unique_ptr
snippet up
auto ${1} = std::make_unique<${2:T}>(${3});
endsnippet

snippet contest "template"
#include <bits/stdc++.h>

using namespace std;

void solve() {
	$0
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	int t;
	cin >> t;
	for (int i = 0; i < t; ++i) {
		solve();
	}
}
endsnippet
